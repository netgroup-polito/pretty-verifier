# Pretty Verifier

**Pretty Verifier** is a tool designed to enhance and simplify the error messages generated by the Linux Kernel's eBPF verifier.

When developing eBPF programs, the verifier can produce cryptic or low-level error outputs that are hard to interpret. Pretty Verifier improves this by combining information from:

- the original `.c` source code,
- the compiled `.o` object file (containing BPF bytecode and DWARF debug symbols),
- the verifier's output.

It produces a clearer, source-level report that highlights the exact locations in the C code where issues occur and provides more insightful explanations, leveraging knowledge from the verifier's internal logic.

Below is an overview of where Pretty Verifier fits into the eBPF development workflow:

![Pretty Verifier role in the eBPF development pipeline](/imgs/pretty_verifier_approach.png)

By analyzing the `.c` file, the compiled `.o` file, and the verifier output, Pretty Verifier returns enhanced error messages that make debugging easier and faster.


# Requirements

- Python3
- eBPF developement tools

If you are on Debian/Ubuntu, you can run:

```bash
sudo apt install linux-headers-$(uname -r) \
                 libbpfcc-dev \
                 libbpf-dev \
                 llvm \
                 clang \
                 gcc-multilib \
                 build-essential \
                 linux-tools-$(uname -r) \
                 linux-tools-common \
                 linux-tools-generic
```
## Kernel Version
The current version of Pretty Verifier works best with distributions using the kernel version 6.8, but it partially works also for older and newer kernel versions.

## Usage

Always compile your code with Clang, using the -g option

Pipe `pretty_verifier.py` when loading the eBPF program.

Pipe with `2>&1 |` in case of `stderr` output (like `bpftool load`)

```bash
bpftool prog load your_bpf_object.o /sys/fs/bpf/your_bpf 2>&1 | python3 path/to/pretty_verifier.py -c your_bpf_source.c -o your_bpf_object.o
```
Custom C user space program, with `libbpf` (printing to `stdin`)

```bash
./your_program | python3 path/to/pretty_verifier.py -c your_bpf_source.c -o your_bpf_object.o
```
If your eBPF program is compiled from multiple files, you can add them in the command

```bash
bpftool prog load your_bpf_object.o /sys/fs/bpf/your_bpf 2>&1 | python3 path/to/pretty_verifier.py -c your_bpf_source.c your_bpf_library.h -o your_bpf_object.o
```

## Add pretty_verifier alias

In order to avoid adding the path of the verifier each time calling it, you can add a pretty_verifier alias.

```bash
echo 'alias pretty-verifier="python3 /path/to/pretty_verifier/pretty_verifier.py"' >> ~/.bashrc
```

So now you can use this notation:

Pipe with `2>&1 |` in case of `stderr` output (like `bpftool load`)

```bash
bpftool prog load your_bpf_object.o /sys/fs/bpf/your_bpf 2>&1 | pretty-verifier -c your_bpf_source.c -o your_bpf_object.o
```
Custom C user space program, with `libbpf` (printing to `stdin`)

```bash
./your_program | pretty-verifier -c your_bpf_source.c -o your_bpf_object.o
```



