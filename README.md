# Pretty Verifier

**Pretty Verifier** is a tool designed to enhance and simplify the error messages generated by the Linux Kernel's eBPF verifier.

When developing eBPF programs, the verifier can produce cryptic or low-level error outputs that are hard to interpret. Pretty Verifier improves the developer's experience by combining information extracted from:

- the original `.c` source code (which is statically analyzed),
- the compiled `.o` object file (containing BPF bytecode and DWARF debug symbols),
- the verifier's output,
- an internal knowledge base derived from the verifier's internal logic and from external public sources.

Pretty Verifier produces a clearer, source-level report that highlights the exact locations in the C code where issues occur and provides insightful explanations and fix suggestions.

Here is an overview of where Pretty Verifier fits into the eBPF development workflow:

![Pretty Verifier role in the eBPF development pipeline](/imgs/pretty_verifier_approach.png)

By analyzing the `.c` file, the compiled `.o` file, and the eBPF verifier output, and by leveraging its internal knowledge base, Pretty Verifier returns enhanced error messages that make debugging easier and faster.


# Requirements

- Python3
- eBPF developement tools

If you are on Debian/Ubuntu, you can run:

```bash
sudo apt install linux-headers-$(uname -r) \
                 libbpfcc-dev \
                 libbpf-dev \
                 llvm \
                 clang \
                 gcc-multilib \
                 build-essential \
                 linux-tools-$(uname -r) \
                 linux-tools-common \
                 linux-tools-generic
```
## Kernel Version
The current version of Pretty Verifier works best with distributions using the kernel version 6.8, but it partially works also for older and newer kernel versions.

## Usage

Currently, Pretty Verifier and the related tools (clang and the eBPF loader/verifier) must be run by the user as explained below. In the future, a script will be provided to run them more seamlessly.

Always compile your eBPF C code with Clang, using the -g option.

Pipe `pretty_verifier.py` when loading the eBPF program, specifying the source and object files through the -c and -o options. 

Here are examples for the two main scenarios:

1. Pipe with `2>&1 |` in case of `stderr` output (like `bpftool load`)

```bash
bpftool prog load your_bpf_object.o /sys/fs/bpf/your_bpf 2>&1 | python3 path/to/pretty-verifier/pretty_verifier.py -c your_bpf_source.c -o your_bpf_object.o
```
2. Custom C user space program, with `libbpf` (printing to `stdin`)

```bash
./your_program | python3 path/to/pretty-verifier/pretty_verifier.py -c your_bpf_source.c -o your_bpf_object.o
```
If your eBPF program is split into multiple source files, you can add them in the command as shown below

```bash
bpftool prog load your_bpf_object.o /sys/fs/bpf/your_bpf 2>&1 | python3 path/to/pretty-verifier/pretty_verifier.py -c your_bpf_source.c your_bpf_library.h -o your_bpf_object.o
```
If you've saved the verifier log into a file (e.g., verifier.log), use the --logfile (-l) option:
```
python3 path/to/pretty_verifier.py -l verifier.log -c your_bpf_source.c -o your_bpf_object.o
```


## Add pretty_verifier alias

In order to avoid adding the path of the verifier each time calling it, you can add a pretty_verifier alias.

```bash
echo 'alias pretty-verifier="python3 /path/to/pretty-verifier/pretty_verifier.py"' >> ~/.bashrc
```

So now you can use this notation:

Pipe with `2>&1 |` in case of `stderr` output (like `bpftool load`)

```bash
bpftool prog load your_bpf_object.o /sys/fs/bpf/your_bpf 2>&1 | pretty-verifier -c your_bpf_source.c -o your_bpf_object.o
```
Custom C user space program, with `libbpf` (printing to `stdin`)

```bash
./your_program | pretty-verifier -c your_bpf_source.c -o your_bpf_object.o
```


## Loader Script Generator

The `generate_bpf_loader.py` utility creates a Bash script to automate the loading of eBPF programs and integration with Pretty Verifier.

### Script generation

To generate a loader script:

```bash
python3 path/to/generate_bpf_loader.py \
    --output-dir <output_directory> \
    [--script-name <script_name>] \
    [--load-line "<custom_load_command>"]
```

- `--output-dir` (**required**): directory where the script will be created.
- `--script-name`: name of the generated script (default: `load.sh`).
- `--load-command`: custom command used to load the eBPF program (optional). By default, the generated script uses `sudo bpftool prog load`.

### Example

Generate a loader script named `load.sh` from the **current directory**:

```bash
python3 generate_bpf_loader.py --output-dir path/to/develpement/directory
```

Generate a loader script from the **developement directory**:

```bash
python3 path/to/pretty-verifier/generate_bpf_loader.py --output-dir .
```

Generate a loader script from the **current directory** with a **custom name** and **custom load command**:

```bash
python3 path/to/pretty-verifier/generate_bpf_loader.py --output-dir ./scripts --script-name my_loader.sh --load-line "sudo bpftool prog load"
```


### Script usage

The generated script accepts one or two arguments:

```bash
./load.sh <source.c> [object.o]
```
- The `<source.c>` argument is required. If only this is provided, the corresponding `.o` filename is inferred by replacing the `.c` extension with `.o`.  
- If the optional `[object.o]` argument is also provided, it overrides the inferred object filename.